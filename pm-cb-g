#!/usr/bin/perl
use warnings;
use strict;
use feature qw{ say };


use Getopt::Long qw( :config no_ignore_case );

my ($bg_color, $fg_color, $author_color, $private_color, $time_color,
    $font_name, $char_size, $stack_size, $seen_color, $mce);

BEGIN {
    ($bg_color, $fg_color, $author_color, $private_color, $time_color,
     $seen_color, $font_name, $char_size, $stack_size, $mce)
        = qw( white black blue magenta darkcyan darkgray Helvetica 12 15 0);

    die "Invalid arguments!\n" unless GetOptions(
        'a|author_color=s'  => \$author_color,
        'b|bg_color=s'      => \$bg_color,
        'c|char_size=i'     => \$char_size,
        'f|fg_color=s'      => \$fg_color,
        'F|font_name=s'     => \$font_name,
        'm|mce'             => \$mce,
        'p|private_color=s' => \$private_color,
        's|stack_size=i'    => \$stack_size,
        'S|seen_color=s'    => \$seen_color,
        't|time_color=s'    => \$time_color,
    );
}


use if $mce => 'MCE::Hobo';
use if $mce => 'MCE::Shared';

use if ! $mce => threads => (stack_size => 2 ** $stack_size);
use if ! $mce => 'Thread::Queue';

my ($queue_class, $queue_constructor, $worker_class)
    = $mce ? ('MCE::Shared',   'queue', 'MCE::Hobo')
           : ('Thread::Queue', 'new',   'threads');

my ($readQ, $writeQ) = map $queue_class->$queue_constructor, 1, 2;
my $communicate_t = $worker_class->create(\&communicate);


use constant {
    PM_URL => 'http://www.perlmonks.org/bare/?node_id=',
    FREQ   => 7,
    # Node ids:
    LOGIN   => 109,
    CB      => 207304,
    SEND    => 227820,
    PRIVATE => 15848,
};

use constant TITLE => 'PM::CB::G';

gui();


sub communicate {
    require XML::LibXML;
    require WWW::Mechanize;
    require Time::HiRes;

    my $mech = 'WWW::Mechanize'->new;

    my ($from_id, $previous, %seen);

    my $last_update = -1;
    my ($message, $command);
    my %dispatch = (
        login => sub { login($mech, @$message)
                           or $readQ->enqueue(['login']) },
        send  => sub { $message->[0] =~ tr/\x00-\x20/ /s;
                       send_message($mech, $message->[0]) },
        quit  => sub { no warnings 'exiting'; last },
    );

    while (1) {
        if ($message = $writeQ->dequeue_nb) {
            $command = shift @$message;
            $dispatch{$command}->();
        }

        Time::HiRes::usleep(250_000);
        next if time - $last_update < FREQ;
        $last_update = time;

        my $url = PM_URL . CB;
        $url .= ";fromid=$from_id" if defined $from_id;
        $mech->get($url);

        my $xml = 'XML::LibXML'->load_xml(string => $mech->content);

        my $time = $xml->findvalue('/chatter/info/@gentimeGMT');
        $readQ->enqueue([ time => $time ]);

        my @messages = $xml->findnodes('/chatter/message');

        for my $message (@messages) {
            my $id = $message->findvalue('message_id');
            if (! exists $seen{$id}) {
                $readQ->enqueue([ chat => $time,
                                          $message->findvalue('author'),
                                          $message->findvalue('text') ]);
                undef $seen{$id};
            }
        }

        my $new_from_id = $xml->findvalue(
            '/chatter/message[last()]/message_id');
        $from_id = $new_from_id if length $new_from_id;

        $previous = $xml;

        my @private = get_all_private($mech, \%seen);
        for my $msg (@private) {
            $readQ->enqueue([
                private => @$msg{qw{ author time text }}
            ]) unless exists $seen{"p$msg->{id}"};
            undef $seen{"p$msg->{id}"};
        }
    }
}


sub login {
    my ($mech, $username, $password) = @_;
    $mech->get(PM_URL . LOGIN);
    $mech->submit_form(
        form_number => 1,
        fields      => { user   => $username,
                         passwd => $password,
    });
    return $mech->content !~ /^Oops\.  You must have the wrong login/m
}


sub send_message {
    my ($mech, $message) = @_;
    return unless length $message;

    ( my $msg = $message )
        =~ s/(.)/ord $1 > 127 ? '&#' . ord($1) . ';' : $1/ge;
    my $response = $mech->post(
        PM_URL . SEND,
        Content   => { op      => 'message',
                       node    => SEND,
                       message => $msg }
    );
    my $content = $response->content;
    $readQ->enqueue([ private => '<pm-cb-g>', undef, $content ])
        unless $content =~ /^Chatter accepted/;
}


sub get_all_private {
    my ($mech, $seen) = @_;

    my $url = PM_URL . PRIVATE;

    my ($max, @private);
  ALL:
    while (1) {
        $mech->get($url);
        last unless $mech->content =~ /</;
        my $xml = 'XML::LibXML'->load_xml(string => $mech->content);
        my @messages;
        last unless @messages = $xml->findnodes('/CHATTER/message');

        for my $msg (@messages) {
            my $id = $msg->findvalue('@message_id');
            last ALL if $seen->{"p$id"};

            push @private, {
                author => $msg->findvalue('@author'),
                time   => $msg->findvalue('@time'),
                text   => $msg->findvalue('text()'),
                id     => $id,
            };
        }

        my $first = $messages[0]->findvalue('@message_id');
        $url = PM_URL . PRIVATE . "&prior_to=$first";
    }

    return @private
}


sub gui {
    require Time::Piece;
    my $tzoffset = Time::Piece::localtime()->tzoffset;
    my $last_date = q();

    require Tk;
    'Tk'->import;

    require Tk::Dialog;
    require Tk::ROText;

    my $mw = 'MainWindow'->new(-title => TITLE);
    $mw->protocol(WM_DELETE_WINDOW => \&quit);
    $mw->optionAdd('*font', "$font_name $char_size");

    my $read_f = $mw->Frame->pack(-expand => 1, -fill => 'both');
    my $read   = $read_f->ROText(-background => $bg_color,
                                 -foreground => $fg_color,
                                 -wrap       => 'word')
        ->pack(-expand => 1, -fill => 'both');
    $read->tagConfigure(author  => -foreground => $author_color);
    $read->tagConfigure(private => -foreground => $private_color);
    $read->tagConfigure(seen    => -foreground => $seen_color);
    $read->tagConfigure(time    => -foreground => $time_color);

    my $last_update_f = $mw->Frame->pack;
    $read_f->Label(-text => 'Last update:')->pack(-side => 'left');
    my $last_update = $read_f->Label->pack(-side => 'left');

    my $write_f = $mw->Frame->pack(-fill => 'x');
    my $write   = $write_f->Text(-height     => 3,
                                 -background => $bg_color,
                                 -foreground => $fg_color,
                                 -wrap       => 'word')
        ->pack(-fill => 'x');

    my $button_f = $mw->Frame->pack;
    my $send_b = $button_f->Button(-text => 'Send',
                                   -command => sub {
                                       $writeQ->enqueue(
                                           [ send => $write->Contents ]);
                                       $write->Contents(q());
                                   }
                                  )->pack(-side => 'left');
    $mw->bind("<$_>", sub { $write->delete('insert - 1 char');
                            $send_b->invoke }
    ) for qw( Return KP_Enter );

    my $seen_b = $button_f->Button(-text => 'Seen',
                                   -command => sub { seen($read, $mw) },
                                   -underline => 0,
                                  )->pack(-side => 'left');
    $mw->bind('<Alt-s>', sub { $seen_b->invoke });

    my $quit_b = $button_f->Button(-text => 'Quit',
                                   -command => \&quit,
                                   -underline => 0,
                                  )->pack(-side => 'left');
    $mw->bind('<Alt-q>', sub { $quit_b->invoke });

    my ($username, $password);

    $mw->repeat(1000, sub {
        my $msg;
        my %dispatch = (
            time    => sub { update_time($last_update, $msg->[0], $tzoffset,
                                         \$last_date) },
            login   => sub { login_dialog($mw) },
            chat    => sub { show_message($read, $last_date, $tzoffset, @$msg);
                             increment_unread($mw); },
            private => sub { show_private($read, @$msg, $tzoffset);
                             increment_unread($mw); },
        );
        while ($msg = $readQ->dequeue_nb) {
            my $type = shift @$msg;
            $dispatch{$type}->();
        }
    });

    $mw->after(1, sub { login_dialog($mw); $write->focus; });

    MainLoop();
}


sub increment_unread {
    my ($mw) = @_;
    my $title = $mw->cget('-title');
    if ($title =~ s/([0-9]+)/$1 + 1/e) {
        $mw->configure(-title => $title);
    } else {
        $mw->configure(-title => '[1] ' . TITLE);
    }
}


sub seen {
    my ($read, $mw) = @_;
    while (my ($from, $to) = $read->tagNextrange('unseen', '1.0')) {
        $read->tagRemove('unseen', $from, $to);
        $read->tagAdd('seen', $from, $to);
    }
    $mw->configure(-title => TITLE);
}


sub decode {
    require Encode;
    require charnames;
    my ($msg) = @_;
    $msg = Encode::decode('UTF-8', $msg);
    $msg =~ s/&#(x?)([0-9]+);/$1 ? chr hex $2 : chr $2/ge;
    $msg =~ s/([^\0-\x{FFFF}])/
              "\x{2997}" . charnames::viacode(ord $1) . "\x{2998}"/ge
        if 'MSWin32' eq $^O;
    return $msg
}


sub show_message {
    my ($text, $last_date, $tzoffset, $timestamp, $author, $message) = @_;

    $message = decode($message);
    $timestamp = convert_time($timestamp, $tzoffset)
                 ->strftime('%Y-%m-%d %H:%M:%S');

    substr $timestamp, 0, 11, q() if 0 == index $timestamp, $last_date;
    $text->insert(end => "<$timestamp>", ['time']);
    $text->insert(end => " [$author]: ", ['author']);
    $text->insert(end => "$message\n", ['unseen']);
    $text->see('end');
}


sub show_private {
    my ($text, $author, $time, $msg, $tzoffset) = @_;
    $msg = decode($msg);
    $msg =~ s/[\n\r]//g;

    if (defined $time) {
        local $ENV{TZ} = 'America/New_York';
        my $est = Time::Piece::localtime()->tzoffset;
        $time = 'Time::Piece'->strptime($time, '%Y-%m-%d %H:%M:%S')
              - $est + $tzoffset;
    } else {
        $time = Time::Piece::localtime();
    }
    $time = $time->strftime('%Y-%m-%d %H:%M:%S');

    $text->insert(end => "<$time>", ['time']);
    $text->insert(end => " [$author]: ", ['private']);
    $text->insert(end => "$msg\n", ['unseen']);
    $text->see('end');
}


sub convert_time {
    my ($server_time, $tzoffset) = @_;
    my $local_time = 'Time::Piece'->strptime(
        $server_time, '%Y-%m-%d %H:%M:%S'
    ) + $tzoffset;  # Assumption: Server time is in UTC.
    return $local_time
}

sub update_time {
    my ($last_update, $server_time, $tzoffset, $last_date) = @_;
    my $local_time = convert_time($server_time, $tzoffset);
    $last_update->configure(
        -text => $local_time->strftime('%Y-%m-%d %H:%M:%S'));
    $$last_date = $local_time->strftime('%Y-%m-%d');
}


sub login_dialog {
    my ($mw) = @_;

    my $login = $mw->Dialog(-title          => 'Login',
                            -default_button => 'Login',
                            -buttons        => [qw[ Login Cancel ]]);

    my $username_f = $login->Frame->pack(-fill => 'both');
    $username_f->Label(-text => 'Username: ')
        ->pack(-side => 'left', -fill => 'x');
    my $username_e = $username_f->Entry->pack(-side => 'left');
    $username_e->focus;

    my $password_f = $login->Frame->pack(-fill => 'both');
    $password_f->Label(-text => 'Password: ')
        ->pack(-side => 'left', -fill => 'x');
    my $password_e = $password_f->Entry(-show => '*')->pack(-side => 'right');

    my $reply = $login->Show;
    quit() if 'Cancel' eq $reply;

    $writeQ->enqueue([ 'login', $username_e->get, $password_e->get ]);
}


sub quit {
    $writeQ->enqueue(['quit']);
    $communicate_t->join;
    Tk::exit();
}
